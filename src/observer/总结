总结

从整个实现和调用过程来看，观察者和监听器模式基本一样。

有兴趣的你可以基于这个模型，实现一个简单微博加关注和取消的功能。 说到底，就是事件驱动模型，将调用者和被调用者通过一个链表、回调函数来解耦掉，相互独立。

整个设计模式的初衷也就是要做到低耦合，低依赖。

再延伸下，消息中间件是什么一个模型？将生产者+服务中心（事件源）和消费者（监听器）通过消息队列解耦掉. 消息这相当于具体的事件对象，只是存储在一个队列里（有消峰填谷的作用），服务中心回调消费者接口通过拉或取的模型响应。 想必基于这个模型，实现一个简单的消息中间件也是可以的。

还比如Guava ListenableFuture，采用监听器模式就解决了future.get()一直阻塞等待返回结果的问题。

有兴趣的同学，可以再思考下观察者和责任链之间的关系， 我是这样看的。

同样会存在一个链表，被观察者会通知所有观察者，观察者自行处理，观察者之间互不影响。 而责任链，讲究的是击鼓传花，也就是每一个节点只需记录继任节点，由当前节点决定是否往下传。 常用于工作流，过滤器Web Filter。